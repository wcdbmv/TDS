# Отчёт
Лабораторная работа 2 по предмету «Типы и структуры данных».<br>
__Керимов Ахмед__, ИУ7-34Б, Вариант 9.

## Техническое задание
__Задача:__ ввести список стран, содержащий название страны, количество жителей,
столицу, материк, основной вид туризма (экскурсионный — количество объектов,
основной вид (природа, история, искусство); пляжный – основной сезон,
температура воздуха и воды, время полёта до страны; спортивный – вид спорта
(горные лыжи, серфинг, восхождения), минимальная стоимость отдыха). Вывести
список стран на выбранном материке, где можно заняться указанным видом отдыха.

__Входные данные:__ файл, содержащий список стран и информацию о них; возможно
добавление стран вручную.

__Выходные данные:__ результат поиска стран по определённому виду туризма на
выбранном материке; список стран, отсортированных по населению; время на
сортировку и поиск.

__Функция программы:__ хранение, считывание и запись таблиц стран, поиск,
сортировка как самой таблицы, так и таблицы ключей, подсчёт времени сортировки.

## Аварийные ситуации
1. Попытка открыть несуществующий файл.

Будет выведено сообщение об ошибке.

2. Файл содержит некорректный формат.

Будет выведено соответствующее сообщение об ошибке с указанием неправильного
столбца.

3. Добавление некорректных данных в таблицу.

Будет повтор ввода с подсказкой о том, какой ожидается ввод.

4. Ошибка выделения памяти.

Будет выведено сообщение об ошибке, программа завершится.

## Структуры

В вариативной части.
```c
//——————————————————————————————————————————————————————————— in tourism_data_t

typedef enum {
	nature, history, art
} excursion_basic_t; // основной вид экскурсии

typedef enum {
	winter, spring, summer, fall
} season_t; // основной пляжный сезон

typedef enum {
	alpine_skiing, surfing, climbing
} sports_basic_t; // основной вид спорта
```

Виды туризма — виды вариативной части.
```c
//———————————————————————————————————————————————————————————————— in tourism_t

typedef struct {
	uint64_t objects;
	excursion_basic_t basic;
} excursion_t; // экскурсионный вид туризма

typedef struct {
	season_t season;
	uint16_t flight_time;
	int8_t air_temp;
	int8_t water_temp;
} beach_t; // пляжный вид туризма

typedef struct {
	uint32_t min_cost;
	sports_basic_t basic;
} sports_t; // спортивный вид туризма
```

Используемые структуры в `country_t`
```c
//———————————————————————————————————————————————————————————————— in country_t

typedef enum {
	africa, eurasia, north_america, south_america, antarctica, australia
} continent_t; // материк

typedef enum {
	excursion, beach, sports
} tourism_t; // туризм

typedef union {
	excursion_t excursion;
	beach_t beach;
	sports_t sports;
} tourism_data_t; // вариативная часть туризма
```

Страна
```c
//———————————————————————————————————————————————————————————————————————— main

#pragma pack(push, 1)
typedef struct {
	char name[STR_LIMIT]; // название
	char capital[STR_LIMIT]; // столица
	tourism_data_t tourism_data; // вариативная часть туризма
	uint64_t population; // население
	size_t id;
	continent_t continent; // материк
	tourism_t tourism; // вид туризма
} country_t;
#pragma pack(pop)
```

Таблица стран
```
typedef struct {
	country_t *data;
	size_t size;
	size_t reserved;
} table_t;

```

Ячейка таблицы ключей
```c
typedef struct {
	uint64_t id;
	uint64_t population;
} key_t;
```

## Функции и алгоритмы

1. Инициализация таблицы, создание, удаление, изменение размера и копирование

```c
void clear_table(table_t *table);
void init_table(table_t *table);
bool table_is_clear(const table_t *table);
bool table_isnt_clear(const table_t *table);

int create_table(table_t *table, const size_t reserve);
void delete_table(table_t *table);
int resize_table(table_t *table, const size_t to);
void copy_table(table_t *to, const table_t *from);
```

Базовые функции для работы с таблицами.

2. Считывание таблицы из файла

```c
int fget_row(FILE *file, table_t *table);
int fget_table(FILE *file, table_t *table);
```

Принимает на вход пустую таблицу, создаёт её и построчно считывает данные из
файла. При необходимости таблица расширяется. При невозможности прочитать
элемент выводится соответствующее сообщение об ошибке, таблица очищается.

3. Вывод таблицы

```c
void write_continent(FILE *file, const continent_t continent);
void write_tourism(FILE *file, const tourism_t tourism);
void write_tourism_data(FILE *file, const country_t *country);
void write_country(FILE *file, const country_t *country, bool id);
void write_table(FILE *file, const table_t *table, bool id);
void print_table(const table_t *table, bool id);
```

Вывод таблицы, или отдельных её частей, с или без `id`.

4. Сортировка таблицы

```c
void copy_country(country_t *to, const country_t *from);
void swap_countries(country_t *a, country_t *b);

void sort_table(table_t *table);
void sort_table2(table_t *table);
```

Пузырьком или выбором.

5. Сортировка таблицы ключей

```c
void swap_keys(key_t *k1, key_t *k2);

void sort_keys(key_t *k, size_t size);
void sort_keys2(key_t *k, size_t size);
```

Пузырьком или выбором.

## Вопросы
1. Как выделяется память под вариантную часть записи?

Выделяется столько памяти, сколько необходимо для наибольшего варианта записи.

2. Что будет, если в вариантную часть ввести данные, несоответствующие
описанным?

В вариативной части будут непредсказуемый значения.

3. Кто должен следить за правильностью выполнения операций с вариантной частью
записи?

Программист.

4. Что представляет собой таблица ключей, зачем она нужна?

Таблица ключей предназначена для оптимизации операции сортировки таблицы путём
некоторого увеличения используемой памяти.

5. В каких случаях эффективнее обрабатывать данные в самой таблице, а когда —
использовать таблицу ключей?

Таблицу ключей стоит использовать, когда записи исходной таблицы содержат много
данных, и их обработка значительно затратнее, чем обработка таблицы ключей.
Таблицу выгодно использовать, когда она маленькая или в ней мало столбцов.

6. Какие способы сортировки предпочтительнее для обработки таблиц и почему?

Если не используется таблица ключей, то можно использовать сортировку выбором,
так как в этом случае количество перестановок в среднем $O(n)$. При
использовании таблицы ключей можно использовать сортировку кучей, т. к. она
имеет асимптотику $O(n\log n)$ и не требует дополнительной памяти.


## Статистика

Sort: B — bubble, S — selection.<br/>
T — table, K — key.
<table>
	<tr>
		<th>Size</th>
		<th>BT</th>
		<th>ST</th>
		<th>BK</th>
		<th>SK</th>
	</tr>
	<tr>
		<th>40</th>
		<td>0.00333</td>
		<td>0.00073</td>
		<td>0.00085</td>
		<td>0.00068</td>
	</tr>
	<tr>
	<th>180</th>
	<td>0.05328</td>
	<td>0.00545</td>
	<td>0.00808</td>
	<td>0.00474</td>
	</tr>
	<tr>
		<th>360</th>
		<td>0.14401</td>
		<td>0.01154</td>
		<td>0.01574</td>
		<td>0.00769</td>
	</tr>

</table>

## Вывод
Применение типа «запись» с вариативной частью целесообразно, так как тип
«запись» позволяет сохранить связанные данные в одном месте (альтернативный
вариант с использованием отдельного массива для хранения каждого элемента
значительно менее удобен), а вариативная часть позволяет сэкономить память для
хранения вариативных данных (выделяется память, необходимая для хранения
наибольшего из вариантов).

Использование дополнительной таблицы ключей даёт прирост скорости примерно 80 %.
При этом используется на 15 % больше памяти. Это что касается сортировки
пузырьком. При сортировке выбором прирост небольшой — примерно 20 %. Это и
понятно, ведь количество перемещений при сортировке выбором линейно.

Преимущества применения таблицы ключей:
* значительный прирост скорости обработки значений;
* возможность обрабатывать значения в оперативной памяти даже если исходная
таблица в неё не помещается.

Недостатки применения таблицы ключей:
* увеличение количества расходуемой памяти.
